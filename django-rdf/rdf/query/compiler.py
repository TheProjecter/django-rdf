"""
Query compiler facade.

Instantiates a ply lexer and parser to generate an abstract syntax tree, 
consisting of collections of namespaces, variables, predicates and constraints. 

The elements of the AST are bound to ontology elements in a separate resolver 
stage before code is generated by the compiler backend.

The resolver also maps generic concepts and predicates to the correct database 
tables. This provides support for querying resources, statements and literals 
that are stored in the RDF models. The resolver achieves this by converting 
RDQL constraints about generic concepts and predicates into equivalent constraints 
about concepts and predicates that are mapped to specific tables. Generally, this 
comes down to replacing a normal constraint with three constraints using the 
built-in rdf:subject, rdf:predicate and rdf:object predicates. Most of the compiler
complexity is a result of this conversion. 
"""

from generate import generate
from resolve import resolve


class Compiler(object):

    def __init__(self):
        self.ast, self.errors = None, []

    def compile(self, rdql):
        from lex import Lexer
        from yacc import Parser
        self.ast = Parser().parse(rdql, lexer=Lexer())
        self.ast = resolve(self.ast) 
        select, count, self.ast = generate(self.ast)
        return select, count
    
    def __getconcepts(self):
        return [c.binding for c in self.ast.concepts]
    concepts = property(__getconcepts)
    
    def __getpredicates(self):
        return [p.binding for p in self.ast.predicates]
    predicates = property(__getpredicates)
    
    def __getmangledpredicates(self):
        return [p.binding.mangled for p in self.ast.predicates]
    mangled_predicates = property(__getmangledpredicates)
    

